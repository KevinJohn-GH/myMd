## 深入理解Python中的参数传递原理

### 1、什么是值的传递与引用传递

##### 如何理解值传递

> 通常就是拷贝参数的值，然后再将拷贝后的值传递给函数里的新变量；
>
> 这样的结果就是：原变量与新变量之间相互独立，互不影响；

##### 如何理解引用传递：

> 通常是指把参数的引用传递给新的变量，这样使得原变量与新变量就会指向同一块内存地址；
>
> 这样的效果是：如果改变了其中任何一个变量的值，那么另外一个变量也会随之改变；

### 2、Python变量及其赋值

##### 案例一

```python
a = 123
print(a, id(a)) 
b = a
print(b, id(b))
a = a + 1
print(a, id(a))
```

##### 输出结果

```
[1, 2, 3] 2181059138120
[1, 2, 3] 2181059138120
[1, 2, 3, 4] 2181059138120
[1, 2, 3, 4] 2181059138120
```

##### 说明：

- `a = 123`：值为123的内存上贴上了a的标签
- `b = a `：值为123的内存上贴上了b的标签
- `a = a + 1`：标签a贴到了值为124的内存上

##### 注意：

- python的数据类型，例如整型`int`，字符串`string`等，是不可变的
- 所以`a = a + 1`，并不是让a的值增加1.而是重新创建了一个值为124的对象，令a指向它
- 但是b仍然不变，仍指向123

##### 案例二

```python
a = [1, 2, 3]
print(a, id(a))
b = a
print(b, id(b))
b.append(4)
print(a, id(a))
print(b, id(b))
```

##### 输出结果

```python
[1, 2, 3] 2539605283400
[1, 2, 3] 2539605283400
[1, 2, 3, 4] 2539605283400
[1, 2, 3, 4] 2539605283400
```

##### 说明：

- `a = [1,2,3] `，`a`变量指向了`[1,2,3]`这个对象
- `b = a`，`b`也指向了`[1,2,3]`这个对象
- `b.append(4)`，对象`[1,2,3]`增加了4
- 故a和b都指向`[1,2,3,4]`

##### 注意：

- python里的变量是可以被删除，但是对象无法被删除。
- 删除变量后无法访问对象，但是对象依然存在。python程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。若对象没有引用，则对象被回收。

##### 总结：在python中

- 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量，而一个对象，可以被多个变量所指向

- 可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量

- 对于不可变对象（字符串、整型、元组等），所有指向该对象的变量的值总是 一样的，也不会改变。

  但是通过某些操作（+=等等）更新不可变对象的值时，会返回一个新的对象

### 3、Python函数的参数传递

准确地说：Python的参数传递是赋值传递`pass by assignment`，或者叫作**对象的引用传递(pass by object reference)**。Python里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或者是引用传递一说。

##### 案例一：不可变对象的参数传递

```python
def func(b): #b和a指向同一个对象
    b = 2   #b指向新的对象2，对a所指对象没有影响
    
a = 1
func(a)
print(a)    #输出结果：1
```

##### 案例二：可变对象的参数传递

```python
def func01(b): 
    b = b + [4] 
    
def func02(b): 
    b.append(4)  
    
a = [1, 2, 3]
func01(a)
print("after append(4):", a)
func02(a)   
print("after +[4]:", a)   
```

##### 输出结果

```python
after append(4): [1, 2, 3]
after +[4]: [1, 2, 3, 4]
```

为什么这时候依然是`[1,2,3]`,而不是`[1,2,3,4]`？

- `first_list.append(4)`只是单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变
- `first_list=first_list + [4]`则是创建了一个新的对象，并赋值给一个本地变量，因此原变量仍然是不变的
- 当给函数传递的是一个可变的数据对象，例如列表、字典等，则最好不要直接修钙对象，可以考虑创建一个新变量，再将新变量返回，返回后重新赋值给变量


### 4、深入理解变量作用域域陷阱 

#### 4.1修改全局的dict不需要global声明

##### 案例一

```python
str = "hhhh"
dict = {"a":1}
def func():
    str = "bbbb"
    dict["b"] = 2
 
func()   
print(str) #输出： hhhh
print(dict) # 输出： {'a': 1, 'b': 2}
```

##### 说明

为什么str在函数体内不需要global()声明就可以修改值？

str是一个字符串（不可变对象），`str =  "bbbb"`是有歧义的，它既可以是在局部变量里面创建一个新的变量，也可以是对全局str进行修改，故默认是创建一个局部变量。

dict是一个字典（可变对象），`dict["b"] = 2`是没有歧义的、确定的，是一个修改语句。

（创建变量语句是`dict = {"b":2}`）,故不需要声明global这一步。

```python
dict = {"a":1}
def func():
    dict = {}
    dict["b"] = 2
 
func()   
print(dict) #输出：{'a': 1}
```

若在函数体内，加上`dict  = {}  `这是一个明确的创建语句，则在局部空间内创建新的变量。 

##### 总结

- int、str等不可变队对象，创建与修改使用同一种语法`x = y `，故产生歧义，需要`global()`声明
- dict、list等可变对象，创建与修改使用的是不同语法，没有歧义，不需要现实调用`global`

#### 4.2 永远不要使用可变的默认参数！！！

##### 错误示范

```pyrhon
def foo(a, b, c=[])
```

正确示范

```python
def foo(a, b, c=None):
    if c is None:
        c = []
```

##### 意想不到的后果

```python
def func(c=[]):
    for i in range(10):
        c.append(i)
    print(c)
        
        
func()
func()
```

##### 输出结果

```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
两次执行`func`的结果不一致

### 5、总结

Python中既不是值传递，也不是引用传递，而是赋值传递

可变对象修改值的两种方法：

- 一种是直接讲可变数据类型（列表、字典、集合）当作参数传入，直接在其上修改
- 第二种是创建一个新的变量，并保存修改后的值，然后返回给原变量
- **工作中，更倾向与后者，清晰明了，不易出错**