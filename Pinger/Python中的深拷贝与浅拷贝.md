## 深入理解Python中的深拷贝与浅拷贝

### 1、浅拷贝

##### 对浅拷贝的理解

>浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是对原对象中子对象的引用。因此，如果原对象中的元素不可变，那倒无所谓；但如果运输可变，浅拷贝通常会带来一些副作用，尤其要注意。

##### 两种浅拷贝的方式：

- 数据构造器方式：`li01 = list(li02)`
- 切片方式：`li01 = li02[:]`

##### 案例一 

```python
print("不可变对象")
a = (1, 2)
b = (1, 2)
print(a is b) # True

print("--------------------")
print("不可变对象嵌套可变对象")
tup01 = (1, 2, [1, 2])
tup02 = (1, 2, [1, 2])
print(tup01 is tup02) # False

print("--------------------")
print("可变对象")
li01 = [1, 2]
li02 = [1, 2]
print(li01 is li02) # False
```

##### 案例二

```python
li03 = [[1,2],(3,4)]
li04 = list(li03) #浅拷贝 另一种方法（切片方法）：li04 = li03[:]
print(li03 is li04) # False
print(li03[0] is li04[0]) # True
print(li03[1] is li04[0]) # True

li03.append("x") #修改对象内的元素
print("li03:", li03) # li03: [[1, 2], (3, 4), 'x']
print("li04:", li04) # li04: [[1, 2], (3, 4)]

li03[0].append("x") #修改对象内子对象的元素
print("li03:", li03) # li03: [[1, 2, 'x'], (3, 4), 'x']
print("li04:", li04) # li04: [[1, 2, 'x'], (3, 4)]

li03[1] += (5,6)
print("li03:", li03) # li03: [[1, 2, 'x'], (3, 4, 5, 6), 'x']
print("li04:", li04) # li04: [[1, 2], (3, 4)]
print(li03[1] is li04[1]) #False
```

##### 说明

`li01 = list(li03)` 浅拷贝，创建一个新的对象，但是里面的元素`[1, 2]`, `(3, 4)`是对原对象中的元素的引用。

故`li03 is li04 `为False

`li03[0] is li04[0]`和`li03[1] = li04[1]`为True

### 2、深拷贝

##### 深拷贝的理解

> 所谓的深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中到1元素，以递归的方式，通过创建新的子对象拷贝到新对象中，因此，新对象和原对象没有任何关联。

python中以`copy.deepcopy()`来实现对象的深度拷贝。比如上述例子写成下面的形式，就是深度拷贝：

```python
import copy

li03 = [[1,2],(3,4)]
li04 = copy.deepcopy(li03) #深拷贝
print(li03 is li04) # False
print(li03[0] is li04[0]) # False
print(li03[1] is li04[1]) # False
```

我们可以看到，无论``li03``如何变化，`li04`都不变。因为此时的`li03`和`li04`完全独立，没有任何关系。

深度拷贝函数`deepcopy`中会维护一个字典，记录已经拷贝的对象与其ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，因此当深度拷贝存在相同的元素时，只会存储一份在字典中。

### 3、总结

对于不可变的对象，比如整数、字符串、元组、还有由这些不可变对象组成的集合对象，浅拷贝和深拷贝没有区别，都是拷贝一个对象；

两者的区别在于：

- 拷贝组合对象，比如列表中还有列表，字典中还有字典或者列表的情况时：
  - 浅拷贝只是拷贝了外面的壳子，里面的元素没有拷贝
  - 而深拷贝则是把壳子和里面的元素都拷贝了一份新的
- 没有限制条件的分片表达式`L[:]` 能够复制字典，但此法只能浅层复制
- 有些内置函数，如`list()`能后生成浅拷贝
- `copy`标准库模版能够生成完整拷贝：`deepcopy()`本质上时递归拷贝
- 对于不可变对象与可变对象来说，浅拷贝都是原对象子对象引用，只是因为拷贝不变对象和拷贝不变对象的引用是等效的（因为不可变对象，当改变时会创建新的对象重新赋值）。所以看起来浅拷贝只拷贝不可变对象（整数、实数、字符串等），对于可变对象，浅拷贝其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了一个标签而已。